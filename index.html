<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Teachable Machine Game Controller</title>
  <style>
    body {font-family: system-ui, sans-serif; background: #0a0f1a; color: #e6eef8; margin: 0; padding: 20px; display: flex; gap: 20px;}
    video {width: 100%; max-width: 360px; background: #000; border-radius: 10px;}
    canvas {background: #111a2b; border-radius: 10px; display: block; margin-top: 10px;}
    button {margin: 5px; padding: 8px 12px; border: none; border-radius: 6px; background: #1f2a44; color: #fff; cursor: pointer;}
    button:hover {background: #2b3a5c;}
    .label {background: #16213a; margin: 4px; padding: 5px 8px; border-radius: 4px; display: inline-block;}
  </style>
</head>
<body>
  <div>
    <h2>Teachable Machine Model</h2>
    <p>Model URL: <code>mXVIPoHTE</code></p>
    <video id="webcam" autoplay playsinline muted></video>
    <div id="labels"></div>
    <div>
      <button id="startBtn">웹캠 시작</button>
      <button id="stopBtn" disabled>중지</button>
    </div>
  </div>
  <div style="flex:1">
    <h2>게임 화면</h2>
    <canvas id="game" width="800" height="400"></canvas>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8/dist/teachablemachine-image.min.js"></script>
  <script>
    const MODEL_URL = 'https://teachablemachine.withgoogle.com/models/mXVIPoHTE/';
    let model, webcamStream, running = false;
    const video = document.getElementById('webcam');
    const labelsDiv = document.getElementById('labels');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const player = {x:100,y:300,w:40,h:60,vx:0,vy:0,speed:3.2,jumpPower:-10,onGround:false};
    const gravity = 0.6;

    async function loadModel() {
      model = await tmImage.load(MODEL_URL + 'model.json', MODEL_URL + 'metadata.json');
      console.log('모델 불러오기 완료');
    }

    async function startWebcam() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
        video.srcObject = stream;
        webcamStream = stream;
        await video.play();
        console.log('웹캠 시작됨');
      } catch (err) {
        alert('웹캠 접근 오류: 브라우저 권한 또는 HTTPS 환경을 확인하세요.\n' + err.message);
        console.error(err);
        throw err;
      }
    }

    function stopWebcam() {
      if (webcamStream) {
        webcamStream.getTracks().forEach(t => t.stop());
        webcamStream = null;
        console.log('웹캠 중지됨');
      }
    }

    async function predict() {
      if (!running || !model) return;
      const prediction = await model.predict(video);
      prediction.sort((a,b)=>b.probability - a.probability);
      const top = prediction[0];
      labelsDiv.innerHTML = prediction.map(p => `<div class='label'>${p.className}: ${(p.probability*100).toFixed(1)}%</div>`).join('');

      if (top.probability > 0.6) {
        controlPlayer(top.className);
      } else {
        controlPlayer('none');
      }
      if (running) requestAnimationFrame(predict);
    }

    function controlPlayer(action) {
      if (action === 'left') player.vx = -player.speed;
      else if (action === 'right') player.vx = player.speed;
      else if (action === 'jump' && player.onGround) { player.vy = player.jumpPower; player.onGround = false; }
      else if (action === 'none') player.vx = 0;
    }

    function updateGame() {
      player.vy += gravity;
      player.x += player.vx;
      player.y += player.vy;
      if (player.y + player.h >= canvas.height - 40) {
        player.y = canvas.height - 40 - player.h;
        player.vy = 0;
        player.onGround = true;
      }
    }

    function drawGame() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#09142c';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#203764';
      ctx.fillRect(0,canvas.height-40,canvas.width,40);
      ctx.fillStyle = '#f5a623';
      ctx.fillRect(player.x,player.y,player.w,player.h);
    }

    function gameLoop() {
      updateGame();
      drawGame();
      requestAnimationFrame(gameLoop);
    }

    startBtn.addEventListener('click', async () => {
      startBtn.disabled = true;
      stopBtn.disabled = false;
      try {
        await loadModel();
        await startWebcam();
        running = true;
        predict();
        gameLoop();
      } catch (err) {
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    });

    stopBtn.addEventListener('click', () => {
      running = false;
      stopWebcam();
      startBtn.disabled = false;
      stopBtn.disabled = true;
    });
  </script>
</body>
</html>
